<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, maximum-scale=1.0" />

    <title>Zoe's HCDE 439 Physical Computing Page!</title>

    <link href="style.css" rel="stylesheet" type="text/css" />

  </head>
  <body>
    <h1>FocusFriend!</h1>

     <div class="image-section">
      <img src="final-picture.jpg" />
    </div>

    <h2>Project Description</h2>
    <p>FocusFriend is a desk buddy that helps you stay focused while working or studying! Personally, I struggle with sitting still for long periods of time to complete tasks, so I wanted to make something I would find helpful.
        It uses a ultrasonic distance sensor to detect when you are present at your desk, and uses audio and visual indicators of different modes. I implemented 3 modes that you can switch between by clicking the button.</p>
    <h3>Modes: </h3>
        <p>IDLE: LED off, no buzzer, no sensor <br> FOCUS: Green LED, warning beep when you go further than 50 cm away <br>BREAK: Blue gradient LED, Break tune, 10 min timer</p>
    <h3>Physical Enclosure: </h3>
        <p>For my physical enclosure, I laser cut a rectangular box out of cardboard to hold my arduino and breadboard with holes to access the individual parts(buzzer, LED, button, distance sensor wires). For the button,
        I made a button extender out of cardboard. I also lasercut 5 sides of a cube(one with a hole for the distance sensor wires) and glued them together on top of the first box to hold the distance sensor upright. 
        <br> For creating the laser cutting design file, it is important to carefully measure the dimensions of the parts and keep in mind the thickness of the cardboard or other material used. I had to redo a few parts due to
        them not fitting right the first time. For the parts that the cardboard fit together, the slots should be a little bit wider than the cardboard's measured thickness. To determine where the holes for the button and other 
        features should be placed, I measured how far they were from the side of the breadboard to use as reference. </p>


    <h2>Technical Implementation</h2>

    <div class="image-section">
      <img src="final-circuit-picture.jpg" />
    </div>

    <div class="image-section">
      <img src="final-schematic.jpg" />
    </div>

     <div class="video-section">
        <h3>Demo Video:</h3>
      <iframe width="560" height="315" src="https://www.youtube.com/embed/x3pz7D4Vr1k?si=p1aC7blaaO_6dw0J" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
    </div>

    <h2>Arduino Code</h2>
    <pre><code>
     // assigning pins for distance sensor
    const int trigPin = A0;
    const int echoPin = A1;

    // assigning pins for button and buzzer
    const int buttonPin = 2;
    const int buzzerPin = 10;

    // assigning pins for RGB LED
    const int red = 9;
    const int green = 6;
    const int blue = 5;


    // variables for break timer
    unsigned long breakStartTime = 0;
    const unsigned long breakDuration = 10UL * 60UL * 1000UL; // 10 minutes
    bool breakAlertPlayed = false;

    // 3 modes
    enum Mode{
      IDLE,
      FOCUS,
      BREAK
    };

    // default mode
    Mode currentMode = IDLE; 

    void setup() {
      // put your setup code here, to run once:
      Serial.begin(9600);

      // initializing pins
      pinMode(trigPin, OUTPUT);
      pinMode(echoPin, INPUT);

      pinMode(buttonPin, INPUT);
      pinMode(buzzerPin, OUTPUT);

      pinMode(red, OUTPUT);
      pinMode(green, OUTPUT);
      pinMode(blue, OUTPUT);

    }

    void loop() {
      // put your main code here, to run repeatedly:
      // run update mode and run mode functions
      updateMode();
      runMode();

    }

    // This function returns the distance from the sensor in cm
    long getDistance() {
      // set trigger pin low
      digitalWrite(trigPin, LOW);
      delayMicroseconds(2);

      // send 10 microsecond high pulse
      digitalWrite(trigPin, HIGH);
      delayMicroseconds(10);
      digitalWrite(trigPin, LOW);

      // measure low long echo pin is high
      long duration = pulseIn(echoPin, HIGH);
      // convert time(microseconds) to distance(cm)
      // divide by 2 because pulse travels from object and back
      long distance = duration * 0.034 / 2;
      return distance;
    }

    // This function reads in from the button
    // returns true once with one clean press
    bool checkButton() {
      // lastState stores button state from last loop
      // low = unpressed
      static bool lastState = LOW;
      // read in current state
      bool currentState = digitalRead(buttonPin);

      // if LOW -> HIGH
      if (lastState == LOW && currentState == HIGH) {
        // delay for debouncing
        delay(20);
        // update current state
        lastState = currentState;
        // new press
        return true;
      }
      lastState = currentState;
      // no new press
      return false;
    }

    // This function switches between modes
    void updateMode() {
      static Mode lastMode = IDLE;
      // switch modes in this order IDLE -> FOCUS -> BREAK -> back to IDLE
      if (checkButton()) {
        if (currentMode == IDLE) {
          currentMode = FOCUS;
        } else if (currentMode == FOCUS) {
          currentMode = BREAK;
        } else {
          currentMode = IDLE;
        }

        // print current mode in monitor for debugging
        Serial.println(currentMode);

        // if switched to break mode, play tune
        if (currentMode == BREAK && lastMode != BREAK) {

            // start 10 min timer
            breakStartTime = millis();
            breakAlertPlayed = false;

          // play tune again after 10 min
          playBreakTune();
        }
        // update last mode
        lastMode = currentMode;
      }
    }

    // This function implements each mode's behaviour
    void runMode() {
      // read distance from sensor
      long distance = getDistance();

      // IDLE mode
      if (currentMode == IDLE) {
        // RGB OFF
        analogWrite(red,   0);
        analogWrite(green, 0);
        analogWrite(blue,  0);

        // no sound
        noTone(buzzerPin);
      }
      // FOCUS mode
      else if (currentMode == FOCUS) {
        // remembers last state
        static bool tooFar = false;
        // when the last beep happened
        static unsigned long lastBeepTime = 0;
        // 1.5 sec cooldown
        const unsigned long beepCooldown = 1500;

        // buffer threshold:
        // turn warning ON above this
        int tooFarOn  = 50;
        // turn warning OFF below this
        int tooFarOff = 40;

        // prevents flickering
        if (distance > tooFarOn) {
          // go into warning state
          tooFar = true;
        }
        if (distance < tooFarOff) {
          // leave warning state
          tooFar = false;
        }

        // start measuring current time
        unsigned long now = millis();

        // only beep is user is too far, and cooldown has passed
        if (tooFar) {
          if (now - lastBeepTime > beepCooldown) {
            pinMode(buzzerPin, OUTPUT);
            tone(buzzerPin, 1000, 200);  // short beep
            lastBeepTime = now;
          }
        } else {
          noTone(buzzerPin);
        }

        // RGB = solid green (full brightness)
        analogWrite(red,   0);
        analogWrite(green, 255);
        analogWrite(blue,  0);
      }

      // BREAK mode
      else if (currentMode == BREAK) {
        // pulsing animation
        int brightness = (sin(millis() / 800.0) + 1) * 127;
        analogWrite(red,   0);
        analogWrite(green, 0);
        analogWrite(blue,  brightness);

        // start tracking time(in milliseconds)
        unsigned long now = millis();

        // When break reaches 10 minutes and alert hasn't played yet
        if (!breakAlertPlayed && (now - breakStartTime >= breakDuration)) {
            // play break tune
            playBreakTune(); 
            breakAlertPlayed = true;
        }

        noTone(buzzerPin);
      }
    }

    // This function plays a tune for break mode
    void playBreakTune() {
      int buzzer = 10;

      // set buzzer to output
      pinMode(buzzerPin, OUTPUT);
      tone(buzzer, 880, 150);
      delay(180);
      tone(buzzer, 988, 150);
      delay(180);
      tone(buzzer, 1047, 200);
      delay(250);

      noTone(buzzer);
      // switch to input to stop noise
      pinMode(buzzerPin, INPUT);
    }
    </code></pre>

  </body>
</html>